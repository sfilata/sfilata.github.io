(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{183:function(e,a,t){"use strict";t.r(a);var r=t(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"react-基本概念以及工作原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-基本概念以及工作原理","aria-hidden":"true"}},[e._v("#")]),e._v(" React 基本概念以及工作原理")]),e._v(" "),t("h2",{attrs:{id:"课程目标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#课程目标","aria-hidden":"true"}},[e._v("#")]),e._v(" 课程目标")]),e._v(" "),t("ul",[t("li",[e._v("了解 React 相关的各种概念")]),e._v(" "),t("li",[e._v("分析 React 的源码")]),e._v(" "),t("li",[e._v("自己动手实现一个简单版的 React")])]),e._v(" "),t("h2",{attrs:{id:"知识要点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#知识要点","aria-hidden":"true"}},[e._v("#")]),e._v(" 知识要点")]),e._v(" "),t("h3",{attrs:{id:"虚拟-dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom","aria-hidden":"true"}},[e._v("#")]),e._v(" 虚拟 Dom")]),e._v(" "),t("p",[e._v("虚拟 Dom 其实就是一个用来表示 Dom 信息和结构的 JS 对象，当状态变更的时候，会重新渲染这个 JS 对象结构")]),e._v(" "),t("p",[e._v("传统 DOM 渲染流程")]),e._v(" "),t("div",{staticClass:"language-mermaid extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("graph LR;\n  HTML --\x3e HTMLParser(HTML Parser)\n  HTMLParser --\x3e DOMTree[/DOM Tree/]\n  DOM --\x3e DOMTree\n  DOMTree --\x3e Attachment\n  Attachment --\x3e RenderTree[/Render Tree/]\n  RenderTree --\x3e Painting & Layout\n  Layout --\x3e RenderTree\n  Painting --\x3e Display\n  StyleSheets(Style Sheets) --\x3e CSSParser(CSS Parser)\n  CSSParser --\x3e StyleRules[/Style Rules/]\n  StyleRules --\x3e Attachment\n")])])]),t("p",[e._v("DOM 操作开销是非常大的，里面包含的属性特别庞大，而且直接操作 DOM 会导致页面重新排版。 所以我们需要使用一种尽可能低成本，无影响的方法去操作 DOM 来更新视图")]),e._v(" "),t("p",[e._v("React 中使用 JSX 语法来描述视图。状态发生变化之后，使用 diff 算法来对比新老视图，依据结果来进行最终的 DOM 操作。")]),e._v(" "),t("blockquote",[t("p",[e._v("JSX 是一种语法糖，使用其来替代常规的 Javascript，看起来很像 HTML 节点。\n使用 JSX 以后，可以免除繁琐的 React.createElement 调用，使编写代码更加容易。\n同时针对 JSX, Ract 会对其进行优化和检查，使其运行更快，而且语法错误在编译阶段时就可以暴露出来。")])]),e._v(" "),t("h3",{attrs:{id:"核心-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心-api","aria-hidden":"true"}},[e._v("#")]),e._v(" 核心 API")]),e._v(" "),t("h4",{attrs:{id:"reactdom-render"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reactdom-render","aria-hidden":"true"}},[e._v("#")]),e._v(" ReactDOM.render")]),e._v(" "),t("p",[e._v("首次调用，没有旧的节点，所以容器节点里的 DOM 元素全部会被替换，在接下来的更新调用时，则会使用 React Diffing alogorithm 算法进行高效更新。")]),e._v(" "),t("blockquote",[t("p",[e._v("提供一个可选的回调函数，回调函数将会在渲染或者更新之后被执行")])]),e._v(" "),t("h2",{attrs:{id:"补充知识点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#补充知识点","aria-hidden":"true"}},[e._v("#")]),e._v(" 补充知识点")]),e._v(" "),t("h4",{attrs:{id:"jsx-react17-与-react18-使用方式的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jsx-react17-与-react18-使用方式的区别","aria-hidden":"true"}},[e._v("#")]),e._v(" JSX React17 与 React18 使用方式的区别")]),e._v(" "),t("p",[e._v("React 17 之前使用 JSX 写代码，是通过 babel-loader 进行转义。在 17 之后，会自动从 React 的 package 中引入新的入口函数并调用。")]),e._v(" "),t("h4",{attrs:{id:"组件的节点类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件的节点类型","aria-hidden":"true"}},[e._v("#")]),e._v(" 组件的节点类型")])])}],!1,null,null,null);a.default=s.exports}}]);