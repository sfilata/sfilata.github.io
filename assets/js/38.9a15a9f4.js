(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{195:function(a,t,v){"use strict";v.r(t);var _=v(0),r=Object(_.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("div",{staticClass:"content"},[v("h1",{attrs:{id:"面试要点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面试要点","aria-hidden":"true"}},[a._v("#")]),a._v(" 面试要点")]),a._v(" "),v("h2",{attrs:{id:"自我介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自我介绍","aria-hidden":"true"}},[a._v("#")]),a._v(" 自我介绍")]),a._v(" "),v("p",[a._v("简洁，点出重点，引导提问项目 1 ～ 3 分钟")]),a._v(" "),v("h2",{attrs:{id:"项目介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#项目介绍","aria-hidden":"true"}},[a._v("#")]),a._v(" 项目介绍")]),a._v(" "),v("p",[a._v("提出项目亮点，使用的技术栈。以及对整个项目技术层面的了解。\n白屏时间，实现各种功能的项目。\n怎么优化，提高团队项目")]),a._v(" "),v("h2",{attrs:{id:"面试过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面试过程","aria-hidden":"true"}},[a._v("#")]),a._v(" 面试过程")]),a._v(" "),v("ul",[v("li",[a._v("前端基础 this, 网络, 事件循环, 写一些简单的逻辑代码")]),a._v(" "),v("li",[a._v("算法，大概率一道中等算法，尽量留一道算法题的时间。(分数占比不高)")]),a._v(" "),v("li",[a._v("有一个自己比较精通的领域，知识点。(Docker, Canvas, node, 性能优化，工程化)")])]),a._v(" "),v("h2",{attrs:{id:"平时准备"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#平时准备","aria-hidden":"true"}},[a._v("#")]),a._v(" 平时准备")]),a._v(" "),v("ul",[v("li",[a._v("尝试找一个觉得有亮点的项目，在公司或者社区中推动")]),a._v(" "),v("li",[a._v("开始前进行技术选型，并清楚这么做的目的")]),a._v(" "),v("li",[a._v("进行中的时候及时记录遇到的困难，积极寻找解决方案")]),a._v(" "),v("li",[a._v("结束的时候进行整理，总结整个项目带来的成长和收获")])]),a._v(" "),v("h2",{attrs:{id:"具体面试题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#具体面试题","aria-hidden":"true"}},[a._v("#")]),a._v(" 具体面试题")]),a._v(" "),v("h3",{attrs:{id:"网络和并发"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络和并发","aria-hidden":"true"}},[a._v("#")]),a._v(" 网络和并发")]),a._v(" "),v("h4",{attrs:{id:"http-1-0-1-1-2-0-在并发请求上主要的区别是什么？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0-1-1-2-0-在并发请求上主要的区别是什么？","aria-hidden":"true"}},[a._v("#")]),a._v(" HTTP/1.0/1.1/2.0 在并发请求上主要的区别是什么？")]),a._v(" "),v("ol",[v("li",[a._v("HTTP 1.0\n每个 TCP 连接只能发送一个请求，当服务器响应后就会关闭这个连接，下一个请求建立新的 TCP 连接\n每个请求只能发一个请求。这个连接是指 HTTP 连接还是 TCP 连接？ TCP 连接\nConnection: keep-alive 可以启用持久连接")]),a._v(" "),v("li",[a._v("HTTP 1.1\n默认采用持久连接，TCP 连接\nConnection: close 可以关闭持久连接\n添加管道机制, 在同一个 TCP 连接里，允许多个请求同时发送。是一问一答的形式。\n因为 TCP 所有的数据通信都是有顺序的，因此为了保持数据的顺序和正确性，可能会导致队头拥塞。")]),a._v(" "),v("li",[a._v("HTTP 2.0\n添加双工模式，客户端和服务端可以同时处理多个请求。解决了队头阻塞的问题。\n添加多路复用技术，没有次序概念。\n增加了服务端推送功能，服务端可以主动发起请求。")])]),a._v(" "),v("h4",{attrs:{id:"http-1-1-的长连接和-http-2-0-的多路复用有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-的长连接和-http-2-0-的多路复用有什么区别","aria-hidden":"true"}},[a._v("#")]),a._v(" HTTP 1.1 的长连接和 HTTP 2.0 的多路复用有什么区别")]),a._v(" "),v("p",[a._v("1.1: 同一时间同一个 TCP 连接只能处理一个请求，采用一问一答的形式。上一个请求响应后才能处理下一个请求。\nChrome 最多支持 6 个并发请求，这是怎么回事？Chrome 允许同时发起 6 个 TCP 连接")]),a._v(" "),v("p",[a._v("2.0: 同域名上的所有通信都在单个连接完成。消除了需要建立多个 TCP 连接的性能损耗。单个连接上可以并行交错的进行请求和响应")]),a._v(" "),v("h4",{attrs:{id:"http-1-1-为什么不能实现多路复用？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-为什么不能实现多路复用？","aria-hidden":"true"}},[a._v("#")]),a._v(" HTTP 1.1 为什么不能实现多路复用？")]),a._v(" "),v("p",[a._v("HTTP 2.0 传输的数据是基于二进制帧进行传输，而 HTTP 1.1 是基于文本解析的协议\n1.1 的报文结构里，服务器需要不断的读入字节，直到遇到换行符，所以处理的顺序必须是串行的。")]),a._v(" "),v("p",[a._v("2.0 的报文结构里以帧为最小数据单位，每个帧都会有标识自己属于哪个流，多个帧组成一个流。")]),a._v(" "),v("p",[a._v("多路复用其实就是一个 TCP 连接里同时存在多个流。")]),a._v(" "),v("h4",{attrs:{id:"前端代码里怎么控制最大并发量？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前端代码里怎么控制最大并发量？","aria-hidden":"true"}},[a._v("#")]),a._v(" 前端代码里怎么控制最大并发量？")]),a._v(" "),v("ul",[v("li",[a._v("基于 Promise 实现一个代码方案，支持限制并发量，控制最大并发量进行传输，可选项可以加入优先级参数")])]),a._v(" "),v("h3",{attrs:{id:"内存处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存处理","aria-hidden":"true"}},[a._v("#")]),a._v(" 内存处理")]),a._v(" "),v("h4",{attrs:{id:"关注过内存处理吗？简述-js-中的内存管理，什么时候会导致内存泄露呢？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关注过内存处理吗？简述-js-中的内存管理，什么时候会导致内存泄露呢？","aria-hidden":"true"}},[a._v("#")]),a._v(" 关注过内存处理吗？简述 js 中的内存管理，什么时候会导致内存泄露呢？")]),a._v(" "),v("p",[a._v("内存分配: 声明变量 函数 对象的时候\n内存使用: 读写内存 使用变量 函数等\n内存回收: 使用完毕，由垃圾回收机制自动回收不再使用的内存")]),a._v(" "),v("p",[a._v("js 中的内存回收机制")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("引用计数法\n看一个对象是否有指向它的引用，如果没有其他对象指向它，则说明此对象不需要了，应该清除\n循环引用问题，导致内存泄漏")])]),a._v(" "),v("li",[v("p",[a._v("标记清除法\n将不再使用的对象定义为无法达到的对象\n检测的时候从 js 的全局对象触发，定时扫描内存中的对象，凡是无法到达的对象则标记为需要清除，稍后等候回收")]),a._v(" "),v("p",[a._v("垃圾收集器在运行的时候会给存储在内存中的所有变量对加上标记\n将从根部触发能够触及到的对象标记清除\n剩下的还有标记的变量视为准备清除的变量\n垃圾收集器销毁所有带有标记的变量，销毁空间")])])]),a._v(" "),v("p",[a._v("常见的内存泄漏")]),a._v(" "),v("ol",[v("li",[a._v("全局变量")]),a._v(" "),v("li",[a._v("未被清理的定时器和回调函数")]),a._v(" "),v("li",[a._v("闭包")]),a._v(" "),v("li",[a._v("DOM 引用")])]),a._v(" "),v("p",[a._v("怎么避免内存泄漏")]),a._v(" "),v("ol",[v("li",[a._v("避免使用全局变量")]),a._v(" "),v("li",[a._v("使用完数据后及时解除变量")]),a._v(" "),v("li",[a._v("注意闭包的使用")]),a._v(" "),v("li",[a._v("避免死循环或者持续执行的操作")])]),a._v(" "),v("h4",{attrs:{id:"实现一个-sizeof-函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现一个-sizeof-函数","aria-hidden":"true"}},[a._v("#")]),a._v(" 实现一个 sizeof 函数")]),a._v(" "),v("p",[a._v("接受一个对象参数，计算传入的对象所占的字节数。")]),a._v(" "),v("ol",[v("li",[a._v("string 类型每个长度占 2 个字节")]),a._v(" "),v("li",[a._v("boolean 类型占 4 个字节")]),a._v(" "),v("li",[a._v("number 占 8 个字节")]),a._v(" "),v("li",[a._v("数组类型占用的空间为数组元素占用的空间之和")]),a._v(" "),v("li",[a._v("对象类型 (null 占 0 字节)\n需要对对象的值进行去重，相同的引用不再重复计算。\n对象类型的总量需要同时加上 key, value 的值")])])])}],!1,null,null,null);t.default=r.exports}}]);