(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{188:function(a,t,s){"use strict";s.r(t);var r=s(0),e=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"js-模块化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-模块化","aria-hidden":"true"}},[a._v("#")]),a._v(" JS 模块化")]),a._v(" "),s("h2",{attrs:{id:"课程目标"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#课程目标","aria-hidden":"true"}},[a._v("#")]),a._v(" 课程目标")]),a._v(" "),s("ul",[s("li",[a._v("理解模块化发展过程，解决的痛点")]),a._v(" "),s("li",[a._v("了解各种模块化方案，熟悉其实现原理")]),a._v(" "),s("li",[a._v("依据面试题目，熟悉巩固模块化相关的知识")])]),a._v(" "),s("h2",{attrs:{id:"知识要点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#知识要点","aria-hidden":"true"}},[a._v("#")]),a._v(" 知识要点")]),a._v(" "),s("h3",{attrs:{id:"概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概念","aria-hidden":"true"}},[a._v("#")]),a._v(" 概念")]),a._v(" "),s("p",[a._v("随着前端的快速发展，代码越来越复杂。需要更好的代码管理，组织，通信的方案。\n模块本质上就是一种提供对外通信的接口，进行代码切分管理的方式。")]),a._v(" "),s("h3",{attrs:{id:"模块化发展进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块化发展进程","aria-hidden":"true"}},[a._v("#")]),a._v(" 模块化发展进程")]),a._v(" "),s("ol",[s("li",[a._v("使用函数利用作用域进行划分")]),a._v(" "),s("li",[a._v("命名空间")]),a._v(" "),s("li",[a._v("使用闭包进行封装 (IIFE)")])]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("global"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" $")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("window"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" jquery"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("主要使用的模块化方案:\nNode: CommonJS -> 逐渐在往 ESM 方向进行转变\n浏览器端: ESM")]),a._v(" "),s("p",[a._v("其他模块化方案：AMD, CMD, UMD")]),a._v(" "),s("h4",{attrs:{id:"commonjs-node-js-介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#commonjs-node-js-介绍","aria-hidden":"true"}},[a._v("#")]),a._v(" CommonJS --\x3e [[Node.js 介绍]]")]),a._v(" "),s("p",[a._v("CommonJS 是同步方案")]),a._v(" "),s("p",[a._v("文件是一种模块，内置 "),s("strong",[a._v("module")]),a._v(", "),s("strong",[a._v("require")]),a._v("两个变量 "),s("code",[a._v("(exports = module.exports)")]),a._v("\n导入导出的机制构成了模块最基本的结构")]),a._v(" "),s("p",[a._v("循环引用问题\n因为 CommonJs 是同步执行的，而且是值拷贝\n在引用的时候，只执行已经输出的部分，忽略未执行的部分\n其中 Require 存在缓存机制，之后执行的时候如果有缓存的化会直接返回")]),a._v(" "),s("h4",{attrs:{id:"esm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#esm","aria-hidden":"true"}},[a._v("#")]),a._v(" ESM")]),a._v(" "),s("p",[a._v("ESM 是异步方案，而且是引用传递\n在执行的时候如果未执行完，则会打上一个类似于拉取中的 Tag。当执行完毕后，因其是引用类型，直接更新掉值即可。\n同样存在缓存机制。")]),a._v(" "),s("h4",{attrs:{id:"amd-异步方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#amd-异步方案","aria-hidden":"true"}},[a._v("#")]),a._v(" AMD 异步方案")]),a._v(" "),s("p",[a._v("依赖前置 -> 在声明阶段即声明所有依赖")]),a._v(" "),s("h4",{attrs:{id:"cmd-异步方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cmd-异步方案","aria-hidden":"true"}},[a._v("#")]),a._v(" CMD 异步方案")]),a._v(" "),s("p",[a._v("依赖后置（按需导入依赖） -> 可以在模块代码中按需进行依赖导入")]),a._v(" "),s("h2",{attrs:{id:"补充知识点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#补充知识点","aria-hidden":"true"}},[a._v("#")]),a._v(" 补充知识点")]),a._v(" "),s("h4",{attrs:{id:"闭包的概念和使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包的概念和使用","aria-hidden":"true"}},[a._v("#")]),a._v(" 闭包的概念和使用")]),a._v(" "),s("p",[a._v("概念：在函数的作用域外依旧持有当前作用域的访问权限。\n函数一般存在栈内存中，闭包既然可以访问到函数的作用域，所以闭包是怎么做到的？\n闭包存在堆里，栈中的函数持有对堆的引用，因此等函数执行完成出栈以后，闭包依然是可访问的。")]),a._v(" "),s("p",[a._v("逃逸分析：浏览器分析哪些变量以后可能还会被用到。")]),a._v(" "),s("h4",{attrs:{id:"同步和异步的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同步和异步的区别","aria-hidden":"true"}},[a._v("#")]),a._v(" 同步和异步的区别")]),a._v(" "),s("p",[a._v("异步更多的与回调函数，发布订阅有关，同步则是顺序执行。同步可能会阻塞，而异步不会。")]),a._v(" "),s("h4",{attrs:{id:"amd-cmd-的大概实现思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#amd-cmd-的大概实现思想","aria-hidden":"true"}},[a._v("#")]),a._v(" AMD, CMD 的大概实现思想")]),a._v(" "),s("p",[a._v("define 函数主要的作用是定义模块, 提取依赖（定义一个 Map 存起来），真正加载的时候是在 Require 的时候")]),a._v(" "),s("h4",{attrs:{id:"主要面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主要面试题","aria-hidden":"true"}},[a._v("#")]),a._v(" 主要面试题")]),a._v(" "),s("p",[a._v("CommonJs, ESM, AMD, CMD 大概的使用方法。（AMD, CMD 大概掌握即可）\nCommonJs, ESM 分别是引用传递还是值传递，是同步还是异步，为什么？(见上文)\nCommonJs, ESM 分别怎么解决循环引用的问题? (中断执行，只输出目前输入的值，再次引入存在缓存机制)")]),a._v(" "),s("h4",{attrs:{id:"跨平台，跨端低代码解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跨平台，跨端低代码解决方案","aria-hidden":"true"}},[a._v("#")]),a._v(" 跨平台，跨端低代码解决方案")]),a._v(" "),s("p",[a._v("运行时解决方案：使用一套通用的配置或者代码（JSON，对象），然后根据各种平台写各种的解析器，通过其针对不同的平台生成相应的代码。\n编译时解决方案：通过 AST 分析，直接进行分析生成相应的各平台代码。")])])}],!1,null,null,null);t.default=e.exports}}]);